<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Was uns C64 Programmierung über JavaScript Architekturen lehren kann</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <!--<link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">-->
    <!--<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">-->
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
    <style>
        /*pre code {*/
            /*display: block;*/
            /*padding: 0.5em;*/
            /*background: #FFFFFF !important;*/
            /*color: #000000 !important;*/
        /*}*/

        .right-img {
            margin-left: 10px !important;
            float: right;
            height: 500px;
        }
        .todo:before {
            content: 'TODO: ';
        }
        .todo {
            color: red !important;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h2>Was uns C64 Programmierung über JavaScript Architekturen lehren kann</h2>
            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
            <p><a href="http://djcordhose.github.io/architecture/c64-web-architecture.html">
                http://djcordhose.github.io/architecture/c64-web-architecture.html
            </a></p>

        </section>

<!--
       60 Minuten
       45 Minuten Vortrag, 15 Minuten Fragen
-->

<!--Die Programmierung des C64, des bekanntesten Heimcomputers der 80er Jahre, mit seinem eingebauten Basic war vor allem eins: -->
<!--leicht zu erlernen, aber wenig mächtig. Einfache Dinge konnte man innerhalb weniger Minuten lösen, -->
<!--aber bei wirklichen Aufgaben musste man auf andere Ansätze wechseln.-->

<!--Ähnliche Erfahrungen haben viele Entwickler erst mit dem JavaScript Framework jQuery und später dann mit AngularJS gemacht. -->
<!--Eben wie bei der C64-Programmierung kommt es auch bei der Webentwicklung darauf an, dass man einen Architektur-Ansatz findet, -->
<!--der dem Problem gerecht wird. Nicht zu einfach, aber auch nicht zu komplex. -->
<!--Dabei kommen insbesondere durch den mächtigen Ansatz von Single-Page Applications ganz neue Anforderungen auf uns zu.-->

<!--In diesem Talk werden wir uns diese Herausforderungen ansehen und passende Architekturmuster am Beispiel der gängigen -->
<!--JavaScript Web-Frameworks wie Angular 2 und React erarbeiten. Zur Sprache kommen dabei sowohl optimierte Komponenten-Hierarchien, -->
<!--als auch moderne Flux-Architekturen. Man darf gespannt sein, wie sich dabei ehemalige Anti-Patterns - z.B. globaler Zustand - zu Best-Practices wandeln.-->

<!--Keine Angst: Um dem Talk folgen zu können, musst du nicht JavaScript programmieren können.-->

<!-- - Schritte-->
    <!-- - C64 Basic zeigen-->
    <!-- - Grenzen-->
    <!-- - Assembler-->
    <!-- - Klassische Web-App zeigen-->
    <!-- - Grenzen-->
    <!-- - SPA-->
    <!-- - SPA erklären-->
    <!-- - Aniti-Patterns-->
        <!-- - React-->
        <!-- - Flux-->
    <!-- - Universal Rendering-->

        <!--Vorbereitung:-->
        <!-- - cd code/universal-->
        <!-- - npm start-->
        <!-- - Checken, dass localhost:3000 im Browser läuft -->

        <section>
            <p>
                <a target="_blank" href="https://entwickler.de/press/javascript-fuer-java-entwickler-4-168852.html">
                    <img src="intro/s-k_JavaScript_fuer_JavaEntwickler_Auflage3_2400x_rgb-220x353@2x.jpg" width="200">
                </a>
                <a target="_blank" href="http://entwickler.de/press/JavaScript-und-TypeScript-fuer-C-Entwickler-174972">
                    <img src="intro/javascript_und_typescript_1400px.jpg" width="200" >
                </a>
                <a target="_blank" href="http://reactbuch.de/">
                    <img src="intro/react.jpg" width="250">                </a>
            </p>
            <a href="http://zeigermann.eu" target="_blank"><img src="intro/SF-Olli.jpg" height="200" align="right"></a>
            <a href="http://www.embarc.de/" target="_blank"><img src="intro/embarc13.png" height="200" align="left"></a>

        </section>

        <section>
            <h2>Worum geht es hier?</h2>
            <p class="fragment">Bei der (Web-)Entwicklung kommt es darauf an, einen Architektur-Ansatz zu finden,
                der dem Problem gerecht wird.
            </p>
            <p class="fragment">Nicht zu einfach, aber auch nicht zu komplex.
            </p>
            <p class="fragment">Problem: Manche naheliegende Ansätze tragen ein Stück weit und lassen uns dann an harte Grenzen stoßen.</p>
        </section>

        <section>
            <h2>Man weiß nicht, was man alles nicht weiß</h2>
            <p class="fragment">Häufig stellen sich erst im Nachhinein gewisse (nicht getroffene) Enscheidungen als Architektur-Entscheidungen heraus
            </p>
            <p class="fragment">Diese können dann den Erfolg des Projekts grundsätzlich gefährden
            </p>
            <p class="fragment">Dieser Talk soll die Grenzen von Web-Architekturen ausloten</p>
        </section>

        <section>
            <h2>Meine erste harte Grenze (#0): C64-Programmierung</h2>
        </section>

        <section>
            <h3>Hello, World</h3>
            <p>Naheliegender Ansatz, schneller Erfolg: Konnte ich noch in der Computerabteilung meines Kaufhauses tippen (1983)</p>
            <div class="fragment" style="height: 400px">
                <img src="c64-hello-world.png">
                <br><small><a target="_blank" href="https://www.kingsquare.nl/jsc64">
                    https://www.kingsquare.nl/jsc64
                </a></small>
            </div>
        </section>

        <section>
            <h3>Was ist eine Computerabteilung?</h3>
            <div class="fragment" style="float: right; width: 450px">
                <img src="computer-abteilung2.jpg">
            </div>
            <div class="fragment" style="float: left; width: 450px">
                <img src="computer-abteilung1.jpg">
            </div>
                <p style="clear: both"><small><a target="_blank" href="http://zockworkorange.com/kaufhauscomputertage/">
                http://zockworkorange.com/kaufhauscomputertage/
            </a></small></p>
        </section>

        <section>
            <h3>Aber wie soll ich das mit C64-Basic machen?</h3>
            <div class="fragment" style="float: left; width: 450px">
                <img src="c64-hellgate.png">
            </div>
            <div class="fragment" style="float: right; width: 450px">
                <img src="c64-rallyspeedway2.png">
            </div>
            <p style="clear: both" class="fragment">
                Man kommt ein Stück weit mit C64 Basic, aber danach muss man alles noch einmal mit Assembler bauen</p>
        </section>

        <section>
            <h2>C64-Trivia</h2>
            <div class="fragment">
                <p>Auch Philipp Rösler hätte gern einen C64 gehabt</p>
                <p>(hatte aber nur einen VC-20)</p>
                <p><small><a target="_blank" href="http://www.zeit.de/politik/ausland/2016-06/philipp-roesler-world-economic-forum-interview">http://www.zeit.de/politik/ausland/2016-06/philipp-roesler-world-economic-forum-interview</a></small></p>
            </div>
        </section>

        <section>
            <h2>Was hat das denn nun mit Web-Architektur zu tun?</h2>
        </section>

        <section>
            <h2>Harte Grenze #1: Klassische Webanwendung</h2>
        </section>

        <section>
            <h3>Klassiche Webanwendung</h3>
            <p><small>jeder Boot tut gut, jeder Roundtrip setzt Zustand zurück</small></p>

            <img src="embarc/KlassischeWebAnwendung.png" style="height: 450px;">
            <p><small>Copyright 2016, embarc</small></p>
        </section>

        <section>
            <h2>Klassichen Webanwendungen</h2>
            <ul class="fragment">
                <li>Browser sendet HTTP-Request und empfängt HTML
                <li>Content wird auf der Server-Seite gerendert
                <li>Jede Interaktion wiederholt diesen Zyklus
            </ul>
        </section>

        <section>
            <h2>Klassische Webanwendung: Oft ein nahe liegender Ansatz</h2>
            <ul class="fragment">
                <li>Klassische Webanwendung sind für viele Enterprise-Entwicklungen der natürliche Ausgangspunkt
                <li>Server-Seitige Entwicklung mit Java/C# und HTTP und HTML sind gut verstanden
                <li>kleinere UI-Änderungen können auf Client-Seite mit JavaScript-Schnippseln (jQuery) realisiert werden
                <li>häufig ist dies völlig ausreichend
            </ul>
        </section>

        <section>
            <h2>Harte Grenze</h2>
            <ul class="fragment">
                <li>UI/UX ist grunsätzlich eingeschränkt
                <li>selbst in vermeintlich klassischen Anwendungen verstecken sich SPAs oft als Teile
                <li>z.B. JSF Komponenten mit einem komplexen UI
            </ul>
            <p class="fragment"><em>Perfide, da zuerst die Aufwände zur Umsetzung ansteigen und der Code immer unübersichtlicher wird.</em></p>
        </section>

        <section>
            <h3>Nächster Schritt: Single-Page Application</h3>
            <img src="embarc/SP-Anwendung.png" style="height: 500px;">
            <p><small>Copyright 2016, embarc</small></p>
        </section>
        <section>
            <h3>Single-Page Applications (SPAs) verschieben eure Anwendung in den Browser</h3>
            <ul class="fragment">
                <li>eine einzige Seite pro Anwendung/Modul
                <li>läuft ohne signifikanten Server-Anteil
                <li>kann auch als statische Web-Seite laufen
                <li>ermöglicht Offline-Betrieb
                <li>Bedienbarkeit wie Desktop
                <li>Browser bietet mächtige Speicherungsmöglichkeiten
            </ul>
        </section>

        <section>
            <h2>Harte Grenze #2: jQuery</h2>
        </section>


        <section>
            <h3>jQuery: Eine Technik mit Tradition</h3>
            <p class="fragment">jQuery ist super, um <em>punktuell</em> mit <em>JavaScript-Schnippseln</em>,
                eine Menge von <em>bestehenden</em> Elementen zu ändern</p>
            <ul class="fragment">
                <li>nicht so gut, wenn es keine <em>bestehenden</em> Elemente gibt: SPA rendert komplett auf Client-Seite
                <li>nicht so gut, wenn die Änderungen nicht <em>punktuell</em> sind: Seiten-Wechesel?
                <li>nicht so gut, wenn <em>JavaScript-Schnippsel</em> nicht reichen: Wer will schon eine echte Anwendung aus Schnippseln zusammen bauen?
            </ul>
            <p class="fragment">Perfide, da für viele Entwickler jQuery das bessere JavaScript ist.</p>
            <p class="fragment">Soll man etwa wieder pures JavaScript machen???</p>

        </section>

        <section>
            <h3>Nächster Schritt: Komponenten basierte Ansätze mit Templates</h3>
            <ul class="fragment">
                <li>nicht so gut, wenn es keine <em>bestehenden</em> Elemente gibt: SPA rendert komplett auf Client-Seite
                <li>nicht so gut, wenn die Änderungen nicht <em>punktuell</em> sind: Seiten-Wechesel?
                <li>nicht so gut, wenn <em>JavaScript-Schnippsel</em> nicht reichen: Wer will schon eine echte Anwendung aus Schnippseln zusammen bauen?
            </ul>
            <p>Erste Vertreter waren Backbone, Angular 1, und Ember.js</p>
        </section>

        <section>
            <h2>Harte Grenze #3: 2-Wege-Data-Binding und Observer-Pattern (Angular 1)</h2>
        </section>

        <section>
            <h2>Nächster Schritt: 1-Wege-Data-Binding und klare Anwendungsstrukturen</h2>
            <p>React und Angular 2</p>
        </section>

        <section>
            <h2>Harte Grenze #4: Verteilter Zustand</h2>
        </section>

        <section>
            <h2>Nächster Schritt: Zustand wird zentral gehalten</h2>
            <p>Flux, Redux, https://github.com/ngrx/store</p>
        </section>

        <section>
            <h2>Harte Grenze #5: SPA selbst</h2>
        </section>

        <section>
            <h3>Probleme von Single-Page Applications</h3>
            <ul class="fragment">
                <li>SEO
                <li>First-Page-Impressions
                <li>Preview, z.B.
                    <ul>
                        <li>bei der Vorschau von Suchergebnissen
                        <li> oder dem Teilen von Links durch Social Media
                    </ul>

                </li>
                <li>Progressive Enhancement
            </ul>
        </section>

        <section>
            <h3>SPA: First-Page-Impression</h3>
            <div>
                <a href="code/spa/public/index.html" target="_blank">
                    <img src="spa-first-page-impression.png" style="height: 500px;">
                </a>
            </div>
        </section>

        <section>
            <h2>Nächster Schritt: Universal Web Apps</h2>
        </section>


        <section>
            <h3>Universal Rendering</h3>
            <ul class="fragment">
                <li>First-Page-Impression wird auf dem Server gerendert
                <li>Links werden als normale HTML-Links in die Seite gerendert
                <li>Beliebig viele andere Seiten werden ebenfalls statisch gerendert
                <li>Läuft dann (zumindest zum Teil) auch ohne JavaScript
                <li>Code fast 100% geteilt zwischen Client und Server
                <li>serverseitiges Rendering mit <a href="https://nodejs.org" target="_blank">https://nodejs.org</a>
                <li>Neben Markup liefert der Browser ebenso Zustand
                <li>Js-Frameworks React und Angular 2 unterstützen serverseitiges Rendering
            </ul>
        </section>

        <section>
            <h3>Universal Rendering am Beispiel von React</h3>
            <div class="fragment">
                <img src="universal.png" style="height: 500px;">
                <p><small><a target="_blank" href="http://reactbuch.de/">Copyright 2016, D-Punkt, http://reactbuch.de/</a></small></p>
            </div>
        </section>

        <section>
            <h3>Universal Rendering: First-Page-Impression</h3>
            <div>
                <a href="http://localhost:3000/" target="_blank">
                    <img src="universal-first-page-impression.png" style="height: 500px;">
                </a>
            </div>
        </section>

        <section>
            <h3>Herausforderungen</h3>
            <ul class="fragment">
                <li>Aller Zustand muss beim serverseitigen Rendering komplett vorliegen
                <li>Unterschiedliche Locales auf Server und Client
                <li>Zeitliche veränderliche Daten (Timestamp, Börsenkurs)
            </ul>
        </section>

        <section>
            <h2>Zusammenfassung</h2>
            <ul>
                <li class="fragment">Man trifft mit vielen Techniken auf harte Grenzen
                <li class="fragment">Es ist wichtig, diese Grenzen zu kennen
                <li class="fragment">Klassische Web-Apps erlauben serverseitiges Rendering
                <li class="fragment">Single-Page Applications erlauben bestes UX
                <li class="fragment">Universal Web Apps verbinden die Fähigkeiten der beiden
            </ul>
        </section>

        <section>
            <h3>The Doctor is In</h3>
            <small>
            <table>
                <tr>
                    <th></th><th>Wissen</th><th>Anforderungen</th><th>A-Z</th>
                </tr>
                <tr>
                    <th>20</th>
                    <td>Muss man für SPAs und Universal Apps JavaScript programmieren?</td>
                    <td>Was ist mit Links und Bookmarks bei SPAs?
                    </td>
                    <td>In welcher Technik sollte ich mein REST-Backend schreiben?
                    </td>
                </tr>
                <tr>
                    <th>40</th>
                    <td></td>
                    <td>Sollte ich nicht jede SPA als Universal App schreiben?
                    </td>
                    <td>Widersprechen SPAs nicht der Grundidee es Webs?
                    </td>
                </tr>
                <tr>
                    <th>60</th>

                    <td><b>Risiko: Frage eurer Wahl</b></td>
                    <td><b>Risiko: Frage eurer Wahl</b></td>
                    <td><b>Risiko: Frage eurer Wahl</b></td>
                </tr>
                <tr>
                    <th>80</th>
                    <td>Wie realisiert man komplexe UI-Komponenten (ala TreeGrid)?
                    </td>
                    <td>Wann passt eine klassische WebApp besser als eine SPA?
                    </td>
                    <td>Wieso funktioniert für SPAs kein Schichtenmodell?
                    </td>
                </tr>
                <tr>
                    <th>100</th>
                    <td>Muss man programmieren können, um die richtigen Entscheidungen zu treffen?</td>
                    <td>Wie kann ich sicher sein, dass ich den richtigen Architektur-Ansatz habe?</td>
                    <td>Wie spielt das alles mit MicroServices zusammen?</td>
                </tr>
            </table></small>
        </section>



        <section>
            <h2>Vielen Dank!</h2>

            <!--<h3>Fragen / Diskussion</h3>-->

            <p>
                <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
                </small>
            </p>
            <a href="http://www.embarc.de/"><img src="intro/embarc13.png"
                                                 height="150"></a>
            <br>
        </section>


        <section class="todo">
            <h1>Ab hier nur noch Material</h1>
        </section>


        <section class="todo">
            <pre>
- den ganzen nachfolgenden Kram überarbeiten und Code entfernen, mehr auf Schwafel-Niveau
- Beautiful constraints (less can be more - for react.js): https://twitter.com/RuhrJS/status/749535474843283457?s=03
- Container vs Component
  - Container Connected to State
  - Only thing that is not Architecture agnostic
  - Component: how things look, views
  - Container: how things work, Controller
  - übernhemen aus: https://speakerdeck.com/mxstbr/scaling-react-dot-js-applications / https://vimeo.com/168648012
- Design: Group by Feature, not by technical function
- Wasserkasten-Bild einbauen
            </pre>

        </section>


        <section>
            <div class="todo">
                <p>https://en.wikiquote.org/wiki/Alan_Kay</p>
                <p>Simple things should be simple, complex things should be possible. (Alan Kay)</p>

            </div>
        </section>


        <section class="todo">
                    <h3>Why not just jQuery?</h3>
                    <ul>
                        <li>jQuery is very good at changing sets of existing elements
                        <li>good if there already are existing elements
                        <li>unobtrusive
                        <li>not so good, if there is nothing to begin with
                        <li>not so good for controlling page flow
                    </ul>
                </section>

                <section class="todo">
                    <h3>Why use a standard Framework?</h3>
                    <ul>
                        <li>avoid the risk of accidentally creating your own
                        <li>use something proven and tested
                        <li>community, documentation
                        <li>easily find skill and talent
                    </ul>
                </section>

                <section class="todo">
                    <h2>Your Options</h2>
                    <ol>
                        <li class="fragment grow">The Classic: Angular 1.x
                        <li class="fragment grow">From Anti-Patterns to Best-Practices: React
                        <li class="fragment grow">One for all: Angular 2
                        <li class="fragment grow">The Standard: Web Components
                        <li class="fragment grow">(I know there is more)
                    </ol>
                </section>



        <section>
            <h3>Container und View-Komponenten</h3>
            <ul class="fragment">
                <li>moderne SPA-Frameworks
                <li>läuft ohne signifikanten Server-Anteil
                <li>kann auch als statische Web-Seite laufen
                <li>ermöglicht Offline-Betrieb
                <li>Bedienbarkeit wie Desktop
                <li>Browser bietet mächtige Speicherungsmöglichkeiten
            </ul>
            <div>
                <img src="component-hierarchy.png">
                <p><small><a href="https://speakerdeck.com/mxstbr/scaling-react-dot-js-applications">
                    Copyright 2016, @mxstbr
                </a></small></p>
            </div>
        </section>

        <section>
            <h2 class="todo">Aus Jan's talk: Motivation für Redux einbauen</h2>

            <!--<section>	-->
				<!--<h2>Flux/Redux<br />Architecture</h2>-->
			<!--</section>-->

			<!--<section>-->
				<!--<ul class="ul1">-->
					<!--<li class="fragment">Key problem #1: <b>complexity</b><br >The bigger a JS application grows, the harder it becomes to manage it's <b>state</b>-->
						<!--<ul class="ul2">-->
							<!--<li class="fragment">-->
								<!--user interaction, event listeners, which elements are shown, how they are shown, ...-->
							<!--</li>-->
							<!--<li class="fragment">-->
								<!--AJAX response handling, callbacks, timeouts/intervals, form data, non-persistent data, (session|local) storage, ...-->
							<!--</li>-->
						<!--</ul>-->
					<!--</li>-->
					<!--<li class="fragment">-->
						<!--<cite style="font-style: italic;">-->
							<!--If a model can update another model, then a view can update a model,-->
							<!--which updates another model, and this, in turn, might cause another-->
							<!--view to update...-->
						<!--</cite>-->
					<!--</li>-->
				<!--</ul>-->
				<!--<aside class="notes" data-markdown>-->
					<!--<div style="font-size:13px;">-->
						<!--<ul>-->
							<!--<li>The bigger an applications grows the more complex it'll get...</li>-->
							<!--<li>...the likelier it may become messed up...</li>-->
							<!--<li>...if there's no real structure and data flow behind it.</li>-->
						<!--</ul>-->
					<!--</div>-->
				<!--</aside>-->
			<!--</section>-->

			<!--<section>-->
				<!--<li class="fragment">At some point you're likely to lose control of when, why and how something happened</li>-->
				<!--<ul class="ul2 fragment">-->
					<!--<li>app becomes opaque and "non-deterministic"</li>-->
					<!--<li>it’s hard to reproduce bugs, do debugging or add new features without introducing new bugs</li>-->
				<!--</ul>-->
				<!--<li class="fragment">Root cause: mutations <u style="text-decoration: underline;">and</u> asynchronicity</li>-->
				<!--<aside class="notes" data-markdown>-->
					<!--<div style="font-size:13px;">-->
						<!--<ul>-->
							<!--<li>no consecutive flow</li>-->
							<!--<li>very hard for humans to reason about</li>-->
							<!--<li>JS mostly is asynchronous (callbacks)-->
								<!--<ul>-->
									<!--<li>event handlers, Ajax</li>-->
									<!--<li>nested callbacks, ...</li>-->
								<!--</ul>-->
							<!--</li>-->
						<!--</ul>-->
					<!--</div>-->
				<!--</aside>-->
			<!--</section>-->

			<!--<section>-->
				<!--<li>Key problem #2: <b>local component states</b></li>-->
				<!--<ul class="ul2">-->
					<!--<li class="fragment">data stored locally inside a component-->
					<!--<ul class="ul2">-->
						<!--<li class="fragment">ok if data is only used for that component</li>-->
						<!--<li class="fragment">BUT: it's often the case that data needs to be shared with other components</li>-->
					<!--</ul>-->
					<!--<li class="fragment">Each component owns a piece of global application state</li>-->
					<!--<li class="fragment">Result: the global state is scattered all over the place</li>-->
				<!--</ul>-->
				<!--<aside class="notes" data-markdown>-->
					<!--<div style="font-size:13px;">-->
						<!--<ul>-->
							<!--<li>Example: Product-&gt;isSelected-->
								<!--<ul>-->
									<!--<li>other products</li>-->
									<!--<li>waiting screen</li>-->
									<!--<li>payment forms</li>-->
									<!--<li>provider select</li>-->
								<!--</ul>-->
							<!--</li>-->
							<!--<li>Bad patterns: trying to keep data in sync manually</li>-->
							<!--<li>Broadcasting:-->
								<!--<ul>-->
									<!--<li>expensive if tree is big</li>-->
									<!--<li>hard to understand where events come from</li>-->
									<!--<li>events may dispatch other events or intercept them</li>-->
									<!--<li>subtree issue</li>-->
								<!--</ul>-->
							<!--</li>-->
							<!--<li>Shared state:-->
								<!--<ul>-->
									<!--<li>business logic spread in each component</li>-->
									<!--<li>writes cannot be restricted</li>-->
								<!--</ul>-->
							<!--</li>-->
						<!--</ul>-->
					<!--</div>-->
				<!--</aside>-->
			<!--</section>-->

			<!--<section>-->
				<!--<h2>Flux/Redux</h2>-->
				<!--<li class="fragment">-->
					<!--Predictable state container for JavaScript apps-->
					<!--<ul class="ul2 fragment">-->
						<!--<li>Application wide state in one centralized, global structure</li>-->
					<!--</ul>-->
				<!--</li>-->
				<!--<li class="fragment">-->
					<!--Unidirectional data flow-->
					<!--&lt;!&ndash;-->
						<!--TODO: -->
							<!-- - "clear" geordneter Data Flow-->
							<!-- - wirklich linear?-->
							<!-- - besser beschreiben-->
					<!--&ndash;&gt;-->
					<!--<ul class="ul2 fragment">-->
						<!--<li>state mutations become transparent and trackable</li>-->
					<!--</ul>-->
				<!--</li>-->
				<!--<li class="fragment">Vuex as adaption for Vue.js</li>-->
				<!--<aside class="notes" data-markdown>-->
					<!--<div style="font-size:13px;">-->
						<!--<ul>-->
							<!--<li>Flux is the architecture idea</li>-->
							<!--<li>Redux is a popular implementation (Facebook)-->
								<!--<ul>-->
									<!--<li>less complex</li>-->
									<!--<li>mostly used with ReactJs, can be used with any other framework.</li>-->
								<!--</ul>-->
							<!--</li>-->
							<!--<li>Has become one of the most important architectures for mid or big scale frontend applications</li>-->
						<!--</ul>-->
					<!--</div>-->
				<!--</aside>-->
			<!--</section>-->

        </section>

        <section>
            <h2>Motivation für eine Flux-Architektur</h2>
        </section>

        <section>
            <h3>Problem von MVC mit Observer-Pattern</h3>
            <div class="fragment">
                <img src="embarc/MVC_1.png" style="height: 500px;">
                <p><small>Copyright 2016, embarc</small></p>
            </div>
        </section>

        <section>
            <h3>Problem von MVC mit Observer-Pattern</h3>
            <div>
                <img src="embarc/MVC_1_blassZustand.png" style="height: 500px;">
                <p><small>Copyright 2016, embarc</small></p>
            </div>
        </section>

        <section>
            <h3>Verteilter, veränderlicher Zustand mit Listenern (Observer)</h3>
            <img class="fragment" src="2-way-data-binding.gif">
        </section>

        <section>
            <h3>Redux, eine Flux Implementierung</h3>
            <div class="fragment">
                <img src="embarc/FluxFWs_Redux.png" style="height: 300px;">
                <p><small>Copyright 2016, embarc</small></p>
            </div>
        </section>

        <section>
            <h3>Redux-Grundidee #1: Fluss in eine Richtung</h3>
            <div class="fragment">
                <img src="embarc/Redux.png" style="height: 500px;">
                <p><small>Copyright 2016, embarc</small></p>
            </div>
        </section>

        <section>
            <h3>Redux-Grundidee #2: Zentraler Zustand</h3>
            <div class="fragment">
                <img src="embarc/Anwendung.png" style="height: 500px;">
                <p><small>Copyright 2016, embarc</small></p>
            </div>
        </section>
        <section>
            <h3>Zusammenfassung Flux/Redux</h3>
            <ul class="fragment">
                <li>Ein Architektur-Ansatz für UIs
                <li>Löst Probleme des klassischen MVC mit Observer-Pattern
                <li>Kontroll-/Datenfluss in eine Richtung
                <li>Gesamter Zustand in einem zentralen Store
            </ul>
        </section>
    </div>

</div>

<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal.js/plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal.js/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal.js/plugin/notes/notes.js', async: true}
        ]
    });

</script>

</body>
</html>
